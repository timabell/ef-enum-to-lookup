using System;
using System.Collections.Generic;
using System.Data.SqlClient;
using System.Text;
using EfEnumToLookup.LookupGenerator.Interfaces;
using EfEnumToLookup.LookupGenerator.Models;

namespace EfEnumToLookup.LookupGenerator
{
	internal class SqlServerHandler : IDbHandler
	{
		/// <summary>
		///     Holds the configuration data
		/// </summary>
		public EnumToLookupConfiguration Configuration { get; set; }

		/// <summary>
		///     Make the required changes to the database.
		/// </summary>
		/// <param name="model">Details of lookups and foreign keys to add/update</param>
		/// <param name="runSql">
		///     A callback providing a means to execute sql against the
		///     server. (Or possibly write it to a file for later use.
		/// </param>
		public void Apply(LookupDbModel model, Action<string, IEnumerable<SqlParameter>> runSql)
		{
			var sql = BuildSql(model);
			runSql(sql, null);
		}

		/// <summary>
		///     Generates the migration SQL needed to update the database to match
		///     the enums in the current model.
		/// </summary>
		/// <param name="model">Details of lookups and foreign keys to add/update</param>
		/// <returns>The generated SQL script</returns>
		public string GenerateMigrationSql(LookupDbModel model)
		{
			return BuildSql(model);
		}

		private string BuildSql(LookupDbModel model)
		{
			var sql = new StringBuilder();
			sql.AppendLine("set nocount on;");
			if (Configuration.UseTransaction)
			{
				sql.AppendLine("set xact_abort on; -- rollback on error");
				sql.AppendLine("begin tran;");
			}

			if (!Configuration.SchemaName.Equals("dbo"))
			{
				sql.AppendLine("-- CREATE CUSTOM SCHEMA --");
				sql.AppendLine($"{IndentLine()}IF SCHEMA_ID('{Configuration.SchemaName}') IS NULL");
				sql.AppendLine($"{IndentLine()}BEGIN");
				sql.AppendLine($"{IndentLine(2)}EXECUTE('CREATE SCHEMA {Configuration.SchemaName}');");
				sql.AppendLine($"{IndentLine()}END");
				sql.AppendLine("");
			}

			sql.AppendLine("-- CREATING ENUM LOOKUP TABLES --");
			sql.AppendLine(CreateTables(model.Lookups));
			sql.AppendLine("-- POPULATING ENUM LOOKUP TABLES --");
			sql.AppendLine(PopulateLookups(model.Lookups));
			sql.AppendLine("-- ADDING FOREIGN KEYS TO MODEL TABLES FOR ENUM LOOKUP TABLES --");
			sql.AppendLine(AddForeignKeys(model.References));

			if (Configuration.UseTransaction)
			{
				sql.AppendLine("commit;");
			}
			return sql.ToString();
		}

		private string CreateTables(IEnumerable<LookupData> enums)
		{
			var sql = new StringBuilder();
			foreach (var lookup in enums)
			{
				sql.AppendLine($"{IndentLine()}IF OBJECT_ID('{Configuration.SchemaName}.{TableName(lookup.Name)}','U') IS NULL");
				sql.AppendLine($"{IndentLine()}BEGIN");
				sql.AppendLine($"{IndentLine(2)}CREATE TABLE [{Configuration.SchemaName}].[{TableName(lookup.Name)}] (Id {NumericSqlType(lookup.NumericType)} CONSTRAINT PK_{Configuration.SchemaName}_{TableName(lookup.Name)} PRIMARY KEY, Name NVARCHAR({Configuration.NameFieldLength}));");
				sql.AppendLine($"{IndentLine(2)}exec sys.sp_addextendedproperty @name=N'MS_Description', @level0type=N'SCHEMA', @level0name=N'{Configuration.SchemaName}', @level1type=N'TABLE',@level1name=N'{TableName(lookup.Name)}', @value=N'Automatically generated. Contents will be overwritten on app startup. Table & contents generated by https://github.com/timabell/ef-enum-to-lookup';");
				sql.AppendLine($"{IndentLine()}END");
				sql.AppendLine("");
			}
			return sql.ToString();
		}

		private string AddForeignKeys(IEnumerable<EnumReference> refs)
		{
			var sql = new StringBuilder();
			foreach (var enumReference in refs)
			{
				var fkName = $"FK_{enumReference.ReferencingTable}_{enumReference.ReferencingField}";

				sql.AppendLine($"{IndentLine()}IF OBJECT_ID('{fkName}', 'F') IS NULL");
				sql.AppendLine($"{IndentLine()}BEGIN");
				sql.AppendLine($"{IndentLine(2)}ALTER TABLE [{enumReference.ReferencingTableSchema}].[{enumReference.ReferencingTable}] ADD CONSTRAINT {fkName} FOREIGN KEY ([{enumReference.ReferencingField}]) REFERENCES [{Configuration.SchemaName}].[{TableName(enumReference.EnumType.Name)}] (Id);");
				sql.AppendLine($"{IndentLine()}END");
				sql.AppendLine("");
			}
			return sql.ToString();
		}

		private string PopulateLookups(IEnumerable<LookupData> lookupData)
		{
			var sql = new StringBuilder();
			sql.AppendLine($"{IndentLine()}CREATE TABLE #lookups (Id int, Name nvarchar({Configuration.NameFieldLength}) COLLATE database_default);");
			sql.AppendLine("");

			foreach (var lookup in lookupData)
			{
				sql.AppendLine(PopulateLookup(lookup));
			}

			sql.AppendLine($"{IndentLine()}DROP TABLE #lookups;");
			sql.AppendLine("");
			return sql.ToString();
		}

		private string PopulateLookup(LookupData lookup)
		{
			var sql = new StringBuilder();
			foreach (var value in lookup.Values)
			{
				sql.AppendLine($"{IndentLine()}INSERT INTO #lookups (Id, Name) VALUES ({value.Id}, N'{SanitizeSqlString(value.Name)}');");
			}
			sql.AppendLine("");

			sql.AppendLine($"{IndentLine()}MERGE INTO [{Configuration.SchemaName}].[{TableName(lookup.Name)}] dst");
			sql.AppendLine($"{IndentLine()}USING #lookups src ON src.Id = dst.Id");
			sql.AppendLine($"{IndentLine()}WHEN MATCHED AND src.Name <> dst.Name collate Latin1_General_BIN2 THEN");
			sql.AppendLine($"{IndentLine(2)}UPDATE SET Name = src.Name");
			sql.AppendLine($"{IndentLine()}WHEN NOT MATCHED THEN");
			sql.AppendLine($"{IndentLine(2)}INSERT (Id, Name) VALUES (src.Id, src.Name)");
			sql.AppendLine($"{IndentLine()}WHEN NOT MATCHED BY SOURCE THEN");
			sql.AppendLine($"{IndentLine(2)}DELETE;");
			sql.AppendLine("");
			sql.AppendLine($"{IndentLine()}TRUNCATE TABLE #lookups;");
			sql.AppendLine("");
			return sql.ToString();
		}

		private static string SanitizeSqlString(string value)
		{
			return value.Replace("'", "''");
		}

		private string TableName(string enumName)
		{
			return $"{Configuration.TableNamePrefix}{enumName}{Configuration.TableNameSuffix}";
		}

		private static string NumericSqlType(Type numericType)
		{
			return numericType == typeof(byte) ? "tinyint" : "int";
		}

		private static string IndentLine(int indentCount = 1)
		{
			var indents = new StringBuilder();
			for (var i = 0; i < indentCount; i++)
			{
				indents.Append("\t");
			}
			return indents.ToString();
		}
	}
}